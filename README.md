# PProto

PProto - point-протокол симметричный коммуникационный протокол используемый для передачи команд и данных.
Первый вариант протокола был ориентирован только на бинарную сериализацию. Это определило некоторые детали его реализации, например использование битовых флагов для описания состояния сообщения. Позднее в протокол была добавлена json-сериализация. Сейчас имеется техническая возможность добавлять и другие виды сериализации, но практических планов нет.  
В этом репозитории представлена реализация на C++/Qt. Так же на данный момент существуют реализации на [Python](https://github.com/TochkaAI/pproto_py) и [Java](https://github.com/TochkaAI/pproto-java).
<br>

*Первичные требования к протоколу:*

- бинарная сериализация данных
- поддержка обратной совместимости структур данных в механизме сериализации (версионирование)
- ориентация на проекты написанные на C++/Qt (используются потоковые операторы Qt)
- приоритет удобства использования протокола разработчиком перед универсальностью формата

## Описание протокола
Коммуникационный протокол использует в своей работе три сущности:

- Команда (Command)
- Сообщение (Message)
- Контент сообщения (Content)

#### *Команда*
Команда это 128-ми битный идентификатор (uuid), который определяет выполняемое действие. Условно команду можно охарактеризовать следующими состояниями:

- Command - непосредственно прямая команда на выполнение действия;
- Ansver - ответ (или результат) выполнения команды с типом Command;
- Event - данный тип команды похож на Command, но не предполагает получения ответа (Answer), он используется для рассылки широковещательных сообщений о событиях.

*Примеры команд:*
```cpp
/* Идентификатор неизвестной команды */
QUuidEx Unknown {"4aef29d6-5b1a-4323-8655-ef0d4f1bb79d"}

/* Идентификатор сообщения об ошибке */
QUuidEx Error {"b18b98cc-b026-4bfe-8e33-e7afebfbe78b"}
```

#### *Базовые команды*
Существует минимальный набор команд, поддерживаемый протоколом:

- Информирует противоположную сторону о том, что полученная команда неизвестна  
  `QUuidEx Unknown {"4aef29d6-5b1a-4323-8655-ef0d4f1bb79d"}`
- Команда используется для передачи информации об ошибке  
  `QUuidEx Error {"b18b98cc-b026-4bfe-8e33-e7afebfbe78b"}`
- Запрос информации о совместимости. При подключении клиент и сервер отправляют друг другу информацию о совместимости. Это основополагающая команда, если она не будет отправлена/получена, то не произойдет запуск очереди обработки сообщений для установленного соединения  
  `QUuidEx ProtocolCompatible {"173cbbeb-1d81-4e01-bf3c-5d06f9c878c3"}`
-   Требование закрыть TCP-соединение. Команда работает следующим образом: сторона, которая хочет закрыть соединение отправляет это сообщение  с информацией о причине закрытия соединения. Принимающая сторона записывает эту информацию в свой лог (или использует иным образом), затем отправляет  обратное  пустое сообщение. После того, как ответное сообщение получено TCP-соединение может быть разорвано. Такое поведение реализовано для того чтобы сторона с которой разрывают соединение имела информацию о причине разрыва  
  `QUuidEx CloseConnection {"e71921fd-e5b3-4f9b-8be7-283e8bb2a531"}`
- Команда для проверки актуальности TCP-соединения. Иногда возникают ситуации, когда TCP-соединение "подвисает". При этом разрыва TCP-соединения не происходит, но данные через соединение не передаются. Команда EchoConnection позволяет отслеживать подобные ситуации и принудительно разрывать TCP-соединение. При этом эмитируется сообщение  EchoConnection,  что дает приложению возможность своевременно реагировать на разрыв соединения  
  `QUuidEx EchoConnection {"db702b07-7f5a-403f-963a-ec50d41c7305"}`

Объявление базовых команд находится в файле [commands/base.h](https://github.com/hkarel/PProtoCpp/blob/master/commands/base.h)
<br>

#### *Сообщение*
Сообщение можно представить как некий контейнер использующийся для пересылки команды совместно с данными необходимыми для выполнения этой команды. Наиболее значимые поля сообщения приведены в таблице:

| Поле        | Описание |
|:------------|:---------|
| id          | Идентификатор сообщения (`uuid`) |
| command     | Идентификатор команды (`uuid`) |
| type        | Тип сообщения (`Command`, `Ansver`, `Event`) |
| execStatus  | Статус выполнения/обработки команды |
| priority    | Приоритет сообщения |
| tags        | Содержит список 8-ми байтовых (uint64) значений. Максимальная длина списка 255 элементов. Назначение списка: хранение произвольных пользовательских данных без сериализации их в поле content |
| maxTimeLife | Максимальное время жизни сообщения (используется в механизмах синхронных вызовов) |
| content     | Контент сообщения (полезная нагрузка, сериализованные данные) |
| flags       | Поле битовых флагов, хранит состояние и статусы передаваемого сообщения |

*Побитовое описание поля flags (4 байта, 32 бита)*  
```cpp
--- Байт 1 ---
Тип пересылаемого сообщения, соответствует enum Message::Type (занимает 3 бита)
quint32 type: 3;

Статус выполнения команды, соответствует enum Message::ExecStatus (занимает 3 бита)
quint32 execStatus: 3;

Приоритет сообщения, соответствует enum Message::Priority (занимает 2 бита)
quint32 priority: 2;

--- Байт 2 ---
Параметр определяет два признака:
1) Контент сжат/не сжат;
2) Алгоритм сжатия.
Параметр соответствует enum Message::Compression (занимает 3 бита)
quint32 compression: 3;

Признаки пустых полей. Признаки используются для оптимизации размера сообщения
при его сериализации
quint32 tagsIsEmpty: 1;
quint32 maxTimeLifeIsEmpty: 1;
quint32 contentIsEmpty: 1;
quint32 proxyIdIsEmpty: 1;

quint32 reserved2: 1;

--- Байт 3 ---
quint32 reserved3: 8;

--- Байт 4 ---
Формат сериализации контента, соответствует enum SerializationFormat (занимает 3 бита)
quint32 contentFormat: 3;
quint32 reserved4: 4;

Признак пустого флага _flags2. Признак используется для оптимизации размера 
сообщения при его сериализации. Данный признак идет последним битом в поле _flags
quint32 flags2IsEmpty: 1;
```

Полное описание полей сообщения смотри в модуле [message.h](https://github.com/hkarel/PProtoCpp/blob/master/message.h)  

*Пример записи структуры данных с бинарной- и с json- сериализациями:*
```cpp
struct UserList : Data<&command::UserList,
                        Message::Type::Command,
                        Message::Type::Answer>
{
    QString filter;
    QVector<User> items;

    // Декларация бинарной сериализации
    DECLARE_B_SERIALIZE_FUNC

    // Json-сериализация
    J_SERIALIZE_BEGIN
        J_SERIALIZE_ITEM( filter )
        J_SERIALIZE_ITEM( items  )
    J_SERIALIZE_END
};

// Реализация бинарной сериализации
void UserList::fromRaw(const bserial::RawVector& vect)
{
    B_DESERIALIZE_V1(vect, stream)
    stream >> filter;
    stream >> items;
    B_DESERIALIZE_END
}

bserial::RawVector UserList::toRaw() const
{
    B_SERIALIZE_V1(stream)
    stream << filter;
    stream << items;
    B_SERIALIZE_RETURN
}
```

*Пример записи json-сериализованного сообщения:*
```json
{
    "id":"3caca371-bab1-4758-98db-e1251e49d45f",
    "command":"2ec05fe5-366a-41c9-a283-5a617767738d",
    "flags":2164267082, 
    "content":{"filter":"user*","items":["user1","user2","user3"]}
}
```
*Примечание: значение поля `flags` приведено для примера, оно может отличаться от реального значения.*

#### *Контент сообщения*
Контент - это данные (полезная нагрузка) передаваемые с конкретной командой. Контент может передаваться с любым типом сообщения (Command, Ansver, Event). В контексте языка С++ контент описывается с помощью структуры данных (`struct`). Для того чтобы установить ассоциативную связь между командой и контентом сообщения (структурой данных) используется механизм наследования от базовой структуры `Data`. Так, описание контента сообщения для команды `CloseConnection` будет выглядеть следующим образом
```cpp
struct CloseConnection : Data<&command::CloseConnection,
                               Message::Type::Command>
{
    qint32  group = {0};  // Используется для группировки сообщений
    QUuidEx code;         // Глобальный код причины
    QString description;  // Описание причины закрытия соединения
};
```

В этом примере со структурой `CloseConnection` ассоциируется команда `command::CloseConnection`, а так же структуре назначается атрибут `Message::Type::Command`. Это означает, что данная структура может быть использована в качестве контента только в сообщениях с типом `Command`, но не может быть использована в сообщении с типами `Ansver` и `Event`.

#### *Обработка ошибок*
Для информировании об ошибочной ситуации существует команда `Error`.  
`QUuidEx Error = "b18b98cc-b026-4bfe-8e33-e7afebfbe78b"`

Контент для команды Error выглядит следующим образом:
```cpp
struct Error : Data<&command::Error,
                     Message::Type::Command>
{
    QUuidEx commandId;   // Идентификатор команды
    QUuidEx messageId;   // Идентификатор сообщения
    qint32  group = {0}; // Используется для группировки сообщений по группам
    QUuidEx code;        // Глобальный код ошибки
    QString description; // Описание ошибки
};
```

Однако, наиболее часто для обработки ошибок используется другой механизм: возврат информации об ошибке в сообщении с типом `Message::Type::Answer`. Для этой цели определены две структуры:
```cpp
struct MessageError
{
    qint32  group = {0};  // Используется для группировки сообщений по группам
    QUuidEx code;         // Глобальный код ошибки
    QString description;  // Описание ошибки
};

struct MessageFailed
{
    qint32  group = {0};  // Используется для группировки сообщений по группам
    QUuidEx code;         // Глобальный код неудачи
    QString description;  // Описание неудачи
};
```

Структура `MessageError` предназначена для описания ошибки при выполнении команды. Структура `MessageFailed` используется в том случае, когда выполнение команды не завершилось ошибкой, но и успешного результата тоже нет.  
У сообщения есть специальное поле - `execStatus`, оно описывает результат выполнения операции. Поле `execStatus` имеет смысл только для сообщений с типом `Message::Type::Answer`, в остальных случаях оно имеет неопределенное состояние. Поле `execStatus` может принимать следующие значения:
```cpp
Unknown = 0 // Неопределенное состояние.
Success = 1 // Сообщение было обработано успешно и содержит корректные
            // ответные данные.
Failed  = 2 // Сообщение не было обработано, но результат выполнения не является успешным,
            // но и не является ошибкой. В данном случае сообщение будет содержать данные
            // в формате MessageFailed.
Error   = 3 // При обработке сообщения произошла ошибка. В качестве ответа отправляется
            // сообщения с описанием причины ошибки.
            // В данном случае сообщение будет содержать данные в формате MessageError.
```

*Пример записи сообщения с параметром `execStatus = Error` в json-представлении:*
```json
{
    "id":"7a411ec0-ef09-4bde-a5a5-bc8c709c631d",
    "command":"fc7f12a8-9643-4e81-9d27-53b99c19d319",
    "flags":2164267090,
    "content":
    {
        "group":0,
        "code":"d9a76e6e-c8a1-4217-b8e1-0f7262ecebca",
        "description":"Failed user authorization"
    }
}
```

#### *Порядок установки соединения*
После установки TCP соединения клиент отправляет на сокет сервера сигнатуру протокола. Сигнатура определяет формат сериализации сообщений. Сигнатура является обычным uuid (16 байт в бинарном представлении). Доступные форматы сериализации и их сигнатуры приведены в таблице.

| Формат сериализации | Сигнатура (строковое представление)    |
|:--------------------|----------------------------------------|
| Бинарный            | "82c40273-4037-4f1b-a823-38123435b22f" |
| Json                | "fea6b958-dafb-4f5c-b620-fe0aafbd47e2" |

Если сервер присылает назад этот же uuid, то все ОК - можно работать, иначе TCP соединение разрывается. Сервер ожидает получения сигнатуры протокола в течении 3-х секунд, клиент ожидает ответа от сервера - 6 секунд. Если в течении указанного времени сигнатуры не будут получены - TCP соединение будет разорвано.  
После того как сигнатуры протокола проверены, клиент и сервер отправляют друг другу первое сообщение `ProtocolCompatible`. Это сообщение помимо проверки версий протокола запускает очередь обработки сообщений. Если это сообщение не будет отправлено - механизм не сможет корректно работать, никакие другие сообщения кроме `CloseConnection` не будут обрабатываться.

#### *Порядок передачи коммуникационных пакетов через TCP сокет*
Как было описано ранее сразу после установки TCP соединения клиент и сервер обмениваются сигнатурами протокола (пакеты фиксированной длины в 16 байт). Далее сокеты обмениваются коммуникационными пакетами в следующем формате:  

| Поле  | Описание |
|:------|:---------|
| поле 1 | 4 байта содержат размер пакета (поле соответствует типу integer) |
| поле 2 | пакет данных длиной указанной в поле 1 |

*Примечания:*  

1. Размер пакета в поле 1 записывается в сетевом представлении (порядок байт  big-endian);
2. Если размер пакета меньше нуля, это означает, что пакет сжат с использованием zip-алгоритма. В этом случае размер пакета равен `(поле 1) * -1`. После чтения пакета из буфера сокета нужно провести его декомпрессию.
3. Механизм сжатия (п.2) может быть отключен по согласованию взаимодействующих сторон.

